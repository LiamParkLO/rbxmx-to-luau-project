<!DOCTYPE html>
<html>
<head>
  <title>RBXMX to LuaU Converter</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 300px; margin-top: 1em; }
    #console { color: red; margin-top: 1em; font-weight: bold; display: block; }
  </style>
</head>
<body>
  <h1>RBXMX to LuaU Converter</h1>
  <input type="file" id="file">
  <button id="convert">Convert</button>
  <strong id="console"></strong>
  <textarea id="code" readonly></textarea>

  <script>
    const skipProps = [
      "AttributesSerialize", "Color3uint8", "MaterialColors",
      "PhysicsGrid", "Tags", "Version", "LinkedSource", "ScriptGuid",
      "SmoothGrid"
    ];

    const nonCreatable = new Set([
      "Workspace", "Players", "Lighting", "ReplicatedFirst", "ReplicatedStorage",
      "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack",
      "StarterPlayer", "Teams", "SoundService", "Chat", "LocalizationService",
      "TestService", "RunService", "HttpService", "TweenService", "Terrain",
      "TextService", "LogService", "InsertService", "ContentProvider",
      "PathfindingService", "CollectionService", "MemoryStoreService", "MessagingService"
    ]);

    document.getElementById("convert").addEventListener("click", () => {
      const fileInput = document.getElementById("file");
      const output = document.getElementById("code");
      const consoleOut = document.getElementById("console");
      const file = fileInput.files[0];

      if (!file) {
        consoleOut.textContent = "No file selected.";
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parser = new DOMParser();
          const xml = parser.parseFromString(reader.result, "text/xml");
          const root = xml.querySelector("roblox");

          if (!root) throw new Error("Invalid RBXMX file");

          let result = "--[\ngenerated by liampark_2021's open source .rbxmx to luau converter.\n]\n\n\n\n\n\n\n\n\n\n\n";
          result += 'local v1,v2,v3,v4,v5=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new\nlocal v6=pcall local t,f=true,false\nfunction v7(obj, prop, token)\n    return Enum[tostring(obj[prop]):split(".")[2]][token+1]\nend\n\n';

          root.querySelectorAll(":scope > Item").forEach(item => {
            result += walk(item);
          });

          consoleOut.textContent = "";
          output.value = result.trim();
        } catch (err) {
          consoleOut.textContent = "Error: " + err.message;
          output.value = "";
        }
      };

      reader.onerror = () => {
        consoleOut.textContent = "Error reading file.";
        output.value = "";
      };

      reader.readAsText(file);
    });

    function walk(item, indent = "") {
      const className = item.getAttribute("class");
      const name = sanitizeName(item.getAttribute("name") || "unnamed");
      let code = "";

      if (className === "Terrain") {
        code += `${indent}local ${name}=workspace.Terrain\n`;
      } else if (nonCreatable.has(className)) {
        code += `${indent}local ${name}=game:GetService(\"${className}\")\n`;
      } else {
        code += `${indent}local ${name}=v1(\"${className}\")\n`;
      }

      const props = Array.from(item.querySelector("Properties")?.children || []);
      const lines = parseProps(props, name);
      for (const line of lines) code += `${indent}${line}\n`;

      const children = item.querySelectorAll(":scope > Item");
      for (const child of children) {
        code += walk(child, indent);
        const childName = sanitizeName(child.getAttribute("name") || "unnamed");
        code += `${indent}v6(function() ${childName}.Parent=${name} end)\n`;
      }

      return code;
    }

    function sanitizeName(name) {
      return name.replace(/[^a-zA-Z0-9_]/g, "_");
    }

    function parseProps(props, varName) {
      const lines = [];
      for (const prop of props) {
        const name = prop.getAttribute("name");
        if (skipProps.includes(name)) continue;

        const text = prop.textContent.trim();
        switch (prop.tagName) {
          case "string":
          case "ProtectedString":
            lines.push(`v6(function() ${varName}.${name}=${JSON.stringify(text)} end)`);
            break;
          case "bool":
            lines.push(`v6(function() ${varName}.${name}=${text === "true" ? "t" : "f"} end)`);
            break;
          case "int":
          case "float":
          case "double":
          case "token": 
            lines.push(`v6(function() ${varName}.${name}=v7(${varName}, ${name}, ${Number(text)}) end)`);
            break;
          case "Vector2": {
            const [x2, y2] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v7(${x2}, ${y2}) end)`);
            break;
          }
          case "UDim2": {
            const [sx, ox, sy, oy] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v3(${sx},${ox},${sy},${oy}) end)`);
            break;
          }
          case "BrickColor":
            lines.push(`v6(function() ${varName}.${name}=v4(${Number(text)}) end)`);
            break;
          case "CoordinateFrame": {
            const nums = text.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (nums.length >= 3) {
              lines.push(`v6(function() ${varName}.${name}=v5(${nums.join(",")}) end)`);
            }
            break;
          }
          case "BinaryString":
            break;
          default:
            break;
        }
      }
      return lines;
    }
  </script>
</body>
</html>
